#-*- coding: utf-8 -*-
from __future__ import print_function

import os
import sys
import six
import datetime
if six.PY2:
    import md5
else:
    from hashlib import md5   # python3
import struct
from collections import OrderedDict
from optparse import OptionParser

import yaml

__version__ = '0.0.1dev'

BUILTIN_KEYWORDS = ('namespace', 'version', 'enum', 'struct')
BUILTIN_DATA_TYPES = ('bool int8 uint8 int16 int int32 int64 uint16 uint uint32 uint64 float double str date datetime')
LANGUAGES = (
    # (opt_name, lang_name, dumper_function, extension)
    ('python', 'Python', 'dump_python', '.py'),
    ('csharp', 'C#', 'dump_csharp', '.cs'),
)

def use_ordered_yaml():
    _mapping_tag = yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG
    def dict_representer(dumper, data):
        return dumper.represent_dict(data.iteritems())
    def dict_constructor(loader, node):
        return OrderedDict(loader.construct_pairs(node))
    yaml.add_representer(OrderedDict, dict_representer)
    yaml.add_constructor(_mapping_tag, dict_constructor)
use_ordered_yaml()

def get_exec_name():
    return os.path.basename(sys.argv[0])

def show_version(verbose=False):
    if verbose:
        print('{exec_name} version {version}'.format(exec_name=get_exec_name(), version=__version__))
    else:
        print(__version__)

OPTIONS = (
    {'opt': '--help', 'desc': 'Print this help message and exit.'},
)

def parse_args():
    usage = 'Usage: %prog [OPTION]... SOURCE_FILE'
    parser = OptionParser(usage=usage, version='%prog version {version}'.format(version=__version__))
    parser.add_option("-o", "--out", action="store", default='./', type="string", dest="out_dir", help="prefix PATH to all generated files", metavar='PATH')
    for opt_name, lang_name, _, _ in LANGUAGES:
        parser.add_option(
            '--{opt_name}'.format(opt_name=opt_name),
            action='store_true',
            default=False,
            dest='gen_{opt_name}'.format(opt_name=opt_name),
            help='generate {lang_name} files'.format(lang_name=lang_name))
    return parser.parse_args()


def parse_statement(stat):
    name = ''
    base_type = None

    _name = stat.split(' ')[1]
    if '(' in _name:
        name = _name.split('(')[0]
        base_type = _name.split('(')[1].split(')')[0]
    else:
        name = _name

    return (name, base_type)


def get_python_type(base_type):
    if base_type is None:
        return None
    if base_type.startswith('int') or base_type.startswith('uint'):
        return int
    if base_type in ('float', 'double'):
        return float
    if base_type == 'str':
        return str
    if base_type == 'date':
        return datetime.date
    if base_type == 'datetime':
        return datetime.datetime
    if base_type.endswith('[]'):
        return list

def _get_struct_fmt(var_type, enum_types):
    if var_type == 'bool':
        return '?'
    if var_type == 'int8':
        return 'b'  # char
    if var_type == 'uint8':
        return 'B'  # char
    if var_type == 'int16':
        return 'h'  # short
    if var_type == 'uint16':
        return 'H'  # unsigned short
    if var_type in ('int', 'int32'):
        return 'i'  # integer
    if var_type in ('uint', 'uint32'):
        return 'I'  # unsigned integer
    if var_type == 'int64':
        return 'q'  # long long
    if var_type == 'uint64':
        return 'Q'  # unsigned long long
    if var_type == 'float':
        return 'f'  # float
    if var_type == 'double':
        return 'd'  # double
    if var_type in ('str', 'char[]', 'date', 'datetime'):
        return 's'  # char[]
    if var_type in enum_types:
        return _get_struct_fmt(enum_types[var_type], enum_types)
    return None

def _is_fixed_length_var(var_type, enum_types):
    if var_type in ('bool', 'int16', 'uint16', 'int', 'uint', 'int32', 'uint32', 'int64', 'uint64', 'float', 'double'):
        return True
    if var_type in enum_types:
        return True
    return False

def indent(depth=1):
    return ' ' * depth * 4

def _divide_variables(values, enum_types):
    fixed_len_vars = []
    variable_len_vars = []
    for _k, _v in values.items():
        if _is_fixed_length_var(_v, enum_types):
            fixed_len_vars.append(_k)
        else:
            variable_len_vars.append(_k)
    return fixed_len_vars, variable_len_vars

def dump_python(schema, out_dir, md5sum):
    # header
    code = '# automatically generated by the propy compiler, do not modify\n'
    code += '\n'
    code += '# version [{version}]\n'.format(version=schema['version'])
    code += '# namespace [{namespace}]\n'.format(namespace=schema['namespace'])
    code += '# md5sum [{md5sum}]\n'.format(md5sum=md5sum)
    code += '\n'

    # import
    code += 'import datetime\n'
    code += 'import struct\n'
    enum_count = len([k for k, v in schema.items() if k.startswith('enum ')])
    if enum_count > 0:
        code += 'from collections import namedtuple\n'
    code += 'from collections import OrderedDict\n'

    enum_types = {}
    struct_map = OrderedDict()
    struct_id = 0

    # classes
    for statement, values in schema.items():
        if statement in ('version', 'namespace', md5sum):
            continue
        if statement.startswith('enum '):
            enum_name, base_type = parse_statement(statement)
            python_type = get_python_type(base_type)
            enum_args = dict(
                name=enum_name,
                base_type=base_type or 'int',
                keys=tuple([_k for _k in values.keys()]),
                values=tuple([_v for _v in values.values()]),
            )
            enum_types[enum_name] = enum_args['base_type']
            code += "\n{name} = namedtuple('{name}', {keys})._make({values})\n".format(**enum_args)
        elif statement.startswith('struct '):
            struct_name, base_type = parse_statement(statement)
            python_type = get_python_type(base_type)
            struct_args = dict(
                name=struct_name,
                base_type=base_type or 'object',
                keys=tuple([_k for _k in values.keys()]),
                values=[_v for _v in values.values()]
            )
            if base_type != 'object' and struct_map.get(base_type):
                struct_args['keys'] = struct_map[base_type]['keys'] + struct_args['keys']
                struct_args['values'] = struct_map[base_type]['values'] + struct_args['values']
                values = OrderedDict(zip(struct_args['keys'], struct_args['values']))

            struct_map[struct_name] = struct_args
            # class
            code += '\n\nclass {name}({base_type}):\n'.format(**struct_args)
            #code += indent(1) + "__slots__ = {keys}\n".format(keys=struct_args['keys'])
            struct_id += 1
            code += indent(1) + "__struct_id__ = {struct_id}\n\n".format(struct_id=struct_id)
            code += indent(1) + 'def __init__(self, {keys}):\n'.format(keys=', '.join(struct_args['keys']))
            _added_var_names = []
            if base_type != 'object' and struct_map.get(base_type):
                code += indent(2) + 'super({name}, self).__init__({base_keys})\n'.format(name=struct_args['name'], base_keys=', '.join([_k for _k in struct_map[base_type]['keys']]))
                _added_var_names.extend(struct_map[base_type]['keys'])
            for _k, _v in values.items():
                if _k in _added_var_names:
                    continue
                if _v.endswith('[]'):
                    code += indent(2) + 'self.{var_name} = {var_name} or []\n'.format(var_name=_k)
                else:
                    code += indent(2) + 'self.{var_name} = {var_name}\n'.format(var_name=_k)
                _added_var_names.append(_k)
            code += '\n'
            # _asdict
            code += indent(1) + 'def _asdict(self):\n'
            code += indent(2) + 'return OrderedDict(\n'
            keys = list(values.keys())
            for _k, _v in values.items():
                is_repeated = False
                if _v.endswith('[]'):
                    _v = _v.split('[]')[0]
                    is_repeated = True

                if _v in struct_map:
                    if is_repeated:
                        code += indent(3) + '{var_name}=[_x._asdict() for _x in self.{var_name}]'.format(var_name=_k)
                    else:
                        code += indent(3) + '{var_name}=self.{var_name}._asdict()'.format(var_name=_k)
                else:
                    code += indent(3) + '{var_name}=self.{var_name}'.format(var_name=_k)
                    # if _v in ('date', 'datetime'):
                    #     code += '.isoformat()'
                if keys.index(_k) < len(values) - 1:
                    code += ',\n'
                else:
                    code += '\n' + indent(2) + ')\n'
            code += '\n'
            # _asbytes
            code += indent(1) + 'def _asbytes(self):\n'
            fixed_len_vars, variable_len_vars = _divide_variables(values, enum_types)
            code += indent(2) + "data = b''\n"
            # fixed length values
            struct_fmt = ''
            struct_var = []
            for var_name in fixed_len_vars:
                var_type = values[var_name]
                fmt_char = _get_struct_fmt(var_type, enum_types)
                if fmt_char is None:
                    if var_type in enum_types:
                        raise TypeError("type '{enum_type}' is not allowed: '{var_type}({enum_type})'".format(var_type=var_type, enum_type=enum_types[var_type]))
                    else:
                        raise TypeError("invalid type '{var_type}'".format(var_type=var_type))
                struct_fmt += fmt_char
                struct_var.append(var_name)
            if struct_var:
                code += indent(2) + "data += struct.pack('{fmt}', {values})\n".format(fmt=struct_fmt, values=', '.join(['self.{var_name}'.format(var_name=_var_name) for _var_name in struct_var]))
            # variable length values
            struct_fmt = ''
            struct_var = []
            _added_struct_names = []
            for var_name in variable_len_vars:
                var_type = values[var_name]
                is_repeated = False
                if var_type.endswith('[]'):
                    is_repeated = True
                    var_type = var_type.split('[]')[0]
                # add length
                fmt_char = _get_struct_fmt(var_type, enum_types)
                if fmt_char is None:
                    if var_type in enum_types:
                        raise TypeError("type '{enum_type}' is not allowed: '{var_type}({enum_type})'".format(var_type=var_type, enum_type=enum_types[var_type]))
                    elif var_type in struct_map:
                        if is_repeated:
                            code += indent(2) + "data += struct.pack('H', len(self.{var_name}))\n".format(var_name=var_name)
                            code += indent(2) + "for _x in self.{var_name}:\n".format(var_name=var_name)
                            code += indent(3) + "_data = _x._asbytes()\n"
                            code += indent(3) + "data += struct.pack('H', len(_data))\n"
                            code += indent(3) + "data += _data\n"
                        else:
                            code += indent(2) + "_data = self.{var_name}._asbytes()\n".format(var_name=var_name)
                            code += indent(2) + "data += struct.pack('H', len(_data))\n"
                            code += indent(2) + "data += _data\n"
                        _added_struct_names.append(var_name)
                    else:
                        raise TypeError("invalid type '{var_type}'".format(var_type=var_type))
                if var_name not in _added_struct_names:
                    if is_repeated:
                        code += indent(2) + "data += struct.pack('H', len(self.{var_name}))\n".format(var_name=var_name)
                        code += indent(2) + "for _x in self.{var_name}:\n".format(var_name=var_name)
                        if var_type in ('date', 'datetime'):
                            #code += indent(2) + "_data = self.{var_name}.isoformat().encode('ASCII')\n".format(var_name=var_name)
                            code += indent(3) + "data += struct.pack('{fmt}', _x.isoformat())\n".format(fmt=fmt_char)
                        else:
                            code += indent(3) + "data += struct.pack('{fmt}', _x)\n".format(fmt=fmt_char)
                    else:
                        if var_type in ('date', 'datetime'):
                            code += indent(2) + "_data = self.{var_name}.isoformat().encode('ASCII')\n".format(var_name=var_name)
                        else:
                            code += indent(2) + "_data = self.{var_name}.encode('ASCII')\n".format(var_name=var_name)
                        code += indent(2) + "data += struct.pack('H', len(_data))\n"
                        code += indent(2) + "data += _data\n"
                    _added_struct_names.append(var_name)
                struct_var.append(var_name)
            code += indent(2) + 'return data\n'
            code += '\n'
            # _asbytes
            code += indent(1) + '@classmethod\n'
            code += indent(1) + 'def _frombytes(cls, buf):\n'
            code += indent(2) + '_offset = 0\n'
            # fixed length values
            for var_name in fixed_len_vars:
                var_type = values[var_name]
                fmt_char = _get_struct_fmt(var_type, enum_types)
                code += indent(2) + "_{var_name} = struct.unpack('{fmt_char}', buf[_offset:_offset+{var_size}])[0]; _offset += {var_size}\n".format(var_name=var_name, fmt_char=fmt_char, var_size=struct.calcsize(fmt_char))
            # variable length values
            for var_name in variable_len_vars:
                var_type = values[var_name]
                is_repeated = False
                if var_type.endswith('[]'):
                    is_repeated = True
                    var_type = var_type.split('[]')[0]
                code += indent(2) + "_len = struct.unpack('H', buf[_offset:_offset+2])[0]; _offset += 2\n"
                if var_type in struct_map:
                    if is_repeated:
                        #code += indent(2) + "_cnt = struct.unpack('H', buf[_offset:_offset+2])[0]; _offset += 2\n"
                        code += indent(2) + "_{var_name} = []\n".format(var_name=var_name)
                        code += indent(2) + "for _ in range(_len):\n"
                        code += indent(3) + "_len = struct.unpack('H', buf[_offset:_offset+2])[0]; _offset += 2\n"
                        code += indent(3) + "_{var_name}.append({var_type}._frombytes(buf[_offset:_offset+_len]));_offset += _len\n".format(var_name=var_name, var_type=var_type)
                    else:
                        code += indent(2) + "_{var_name} = {var_type}._frombytes(buf[_offset:_offset+_len]); _offset += _len\n".format(var_name=var_name, var_type=var_type)
                else:
                    fmt_char = _get_struct_fmt(var_type, enum_types)
                    fmt_size = struct.calcsize(fmt_char)
                    if is_repeated:
                        #code += indent(2) + "_cnt = struct.unpack('H', buf[_offset:_offset+2])[0]; _offset += 2\n"
                        code += indent(2) + "_{var_name} = []\n".format(var_name=var_name)
                        code += indent(2) + "for _ in range(_len):\n"
                        if var_type == 'date':
                            code += indent(3) + "_{var_name}.append(datetime.datetime.strptime(struct.unpack('{fmt}', buf[_offset:_offset+{fmt_size}])[0], '%Y-%m-%d').date());_offset += {fmt_size}\n".format(var_name=var_name, fmt=fmt_char, fmt_size=fmt_size)
                        elif var_type == 'datetime':
                            code += indent(3) + "_{var_name}.append(datetime.datetime.strptime(struct.unpack('{fmt}', buf[_offset:_offset+{fmt_size}])[0], '%Y-%m-%dT%H:%M:%S.%f'));_offset += {fmt_size}\n".format(var_name=var_name, fmt=fmt_char, fmt_size=fmt_size)
                        else:
                            code += indent(3) + "_{var_name}.append(struct.unpack('{fmt}', buf[_offset:_offset+{fmt_size}])[0]);_offset += {fmt_size}\n".format(var_name=var_name, fmt=fmt_char, fmt_size=fmt_size)
                    else:
                        if var_type == 'date':
                            code += indent(2) + "_{var_name} = datetime.datetime.strptime(str(buf[_offset:_offset+_len].decode('ASCII')), '%Y-%m-%d').date(); _offset += _len\n".format(var_name=var_name)
                        elif var_type == 'datetime':
                            code += indent(2) + "_{var_name} = datetime.datetime.strptime(str(buf[_offset:_offset+_len].decode('ASCII')), '%Y-%m-%dT%H:%M:%S.%f'); _offset += _len\n".format(var_name=var_name)
                        else:
                            if _is_fixed_length_var(var_type, enum_types):
                                code += indent(2) + "_{var_name} = struct.unpack('{fmt}', buf[_offset:_offset+{fmt_size}])[0];_offset += {fmt_size}\n".format(var_name=var_name, fmt=fmt_char, fmt_size=fmt_size)
                            else:
                                code += indent(2) + "_{var_name} = str(buf[_offset:_offset+_len].decode('ASCII')); _offset += _len\n".format(var_name=var_name)
            code += indent(2) + "return cls(\n"
            keys = list(values.keys())
            for var_name in keys:
                code += indent(3) + "{var_name}=_{var_name}".format(var_name=var_name)
                if keys.index(var_name) < len(keys) - 1:
                    code += ',\n'
                else:
                    code += '\n'
            code += indent(2) + ')\n'
    code += '\n__STRUCT_ID__ = {\n'
    code += ',\n'.join([indent(1) + "{value}: {name}".format(name=_name, value=_idx + 1) for _idx, _name in enumerate(struct_map.keys())])
    code += ',\n}\n'
    code += '\n'
    code += 'def dumps(obj):\n'
    code += indent(1) + '_data = obj._asbytes()\n'
    code += indent(1) + '_len = len(_data)\n'
    code += indent(1) + "return struct.pack('HH', _len, obj.__struct_id__) + _data\n"
    code += '\n'
    code += 'def loads(buf):\n'
    code += indent(1) + '_offset = 0\n'
    code += indent(1) + "_len = struct.unpack('H', buf[_offset:_offset+2])[0]; _offset += 2\n"
    code += indent(1) + "_struct_id = struct.unpack('H', buf[_offset:_offset+2])[0]; _offset += 2\n"
    code += indent(1) + 'cls = __STRUCT_ID__.get(_struct_id, None)\n'
    code += indent(1) + 'if cls is None:\n'
    code += indent(2) + 'raise ValueError("buf can not be deserialized")\n'
    code += indent(1) + 'return cls._frombytes(buf[_offset:])\n'

    return code

def dump_csharp(schema, out_dir, md5sum):
    # header
    code = '// automatically generated by the propy compiler, do not modify\n'
    code += '\n'
    code += '// version [{version}]\n'.format(version=schema['version'])
    code += '// md5sum [{md5sum}]\n'.format(md5sum=md5sum)
    code += '\n'
    code += 'namespace {namespace}\n'.format(namespace=schema['namespace'])
    code += '{\n'
    code += '}\n'

    return code

def get_md5sum(filepath, blocksize=65536):
    if six.PY2:
        _hash = md5.new()
    else:
        _hash = md5()
    with open(filepath, "rb") as f:
        for block in iter(lambda: f.read(blocksize), b""):
            _hash.update(block)
    return _hash.hexdigest()

def generate(options, args):
    # load yaml
    if not args:
        print('Error: missing input file', file=sys.stderr)
        sys.exit(1)
    if len(args) > 1:
        print('Error: multiple input files are not allowed', file=sys.stderr)
        sys.exit(1)
    schema = {}
    md5sum = 'unknown'
    for filepath in args:
        try:
            md5sum = get_md5sum(filepath)
            schema = yaml.load(open(filepath, 'r'))
            break
        except Exception as err:
            print(err)
            print('Error: unable to load file: {filepath}'.format(filepath=filepath), file=sys.stderr)
            sys.exit(1)

    out_dir = options.out_dir
    for opt_name, _, dumper_name, extension in LANGUAGES:
        if getattr(options, 'gen_{opt_name}'.format(opt_name=opt_name)):
            base_filename = '.'.join(os.path.basename(filepath).split('.')[0:-1]) + extension
            out_filepath = os.path.join(out_dir, base_filename)
            if os.path.isfile(out_filepath):
                with open(out_filepath, 'r') as exists_file:
                    first_line = exists_file.readline()
                    if not first_line.endswith(' automatically generated by the propy compiler, do not modify\n'):
                        raise OSError("file '{filepath}' already exists".format(filepath=out_filepath))
            code = globals()[dumper_name](schema=schema, out_dir=out_dir, md5sum=md5sum)
            with open(out_filepath, 'w') as out_file:
                out_file.write(code)
            print("file {filepath} generated".format(filepath=out_filepath))

def main():
    (options, args) = parse_args()
    generate(options, args)
    return 0

if __name__ == '__main__':
    # ex) python papaya.py --python sample.yaml
    sys.exit(main())
